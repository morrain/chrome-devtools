## 如何逐步执行

通过逐步执行代码，可以观察数据的变化，理解页面上为什么会发生变化。还可以通过脚本修改数据，甚至直接修改脚本本身。*为什么变量的值是20而不是30？为什么某一行代码没有任何效果？为什么本来为true的标记，现在却是false?*每一个程序员都面临类似这样的问题，现在让我们通过逐步执行来找到答案吧。

上一节，我们介绍了如何设置断点，现在等在代码中断下来后，我们就可以有选择的逐步执行代码，观察数据的变化。

#### 简而言之

* 在问题出现之前或者出现时，逐步执行代码，期间还可以通过实时编辑测试发生的变化
* 通过逐步执行而不是控制台打印日志来检查数据变化，因为当数据被送到控制台输出时，它可能已经变化了。
* 开启**异步调用栈**特性，对于异步函数会获取更多的信息
* 可以屏蔽第三方JS库的文件，这样以来，在调用堆栈中就不会显示相关第三方JS库的堆栈信息，有时候会很方便我们调试
* 使用具名函数而不是匿名行数，提高调用堆栈的可读性

### 逐步执行操作

在**Sources**面板右上方，有一块可点击的图标区域![](https://developers.google.cn/web/tools/chrome-devtools/javascript/imgs/image_7.png)，这里提供了所有逐步执行的操作，当然它们都有快捷键盘，你可以将鼠标移动到相应图标上面会看到提示。从左往右它们代表的意思如下表：

行为 | 描述
--- | ---
Resume | 恢复代码执行，只到遇到下一个断点
Step Over | 执行到下一行（包括函数）
Step Into | 跳入函数内部执行（当下一步要执行的是一个函数时）
Step Out | 跳出当前函数执行 
Deactivate breakpoints | 临时停用所有断点，用于恢复时不会被中断下来，再次点击会开启所有断点
Pause on exceptions | 当有异常发生时会自动中断（请参考上一节，如何设置异常断点）

可以使用**Step Into**来单行执行代码，它会确保每次只执行一行代码，不论是否遇到函数。当你怀疑是某个未被捕获到的异常导致问题但不知道哪里出了异常时，你可以试试**异常断点**。点击图标开启，再次点击关闭。当开启后，如果勾选了**Pause On Caught Exceptions**，开发者工具只会在那些指定了异常处理函数的异常发生时进行中断。


### 通过作用域查看变量值

当程序被中断后，**Scope**窗口会显示所有在中断那个时刻的变量以及它们的值，如下图蓝色框所示：

![](https://developers.google.cn/web/tools/chrome-devtools/javascript/imgs/scope-pane.png)

**Scope**窗口只会在程序中断时显示那个时刻对应的变量，所以只在程序中断时才会显示内容。正常情况下，该窗口的内容为空。**Scope**窗口显示的内容包括本地变量，闭包变量以及全局变量。当某变量名左侧有一个小箭头图标时表示该变量是一个对象，点击小箭头可以展开查看对象的属性以及其值。有时，某些属性是灰色的，例如下图中`constructor`就比`confirm`要暗一些。亮色的属性表示它是可枚举的，为灰的不能枚举。

![](https://developers.google.cn/web/tools/chrome-devtools/javascript/imgs/enumerables.png)

### 调用栈

在逐步执行的操作条下方便是**Call Stack**窗口。当程序被中断时，调用栈以时间逆序显示了执行到断点处的执行路径。这在调试过程中非常重要，它不仅能告诉我们现在代码执行到哪里了，还能告诉我们代码是怎么一步一步执行到那里的。

例如下图，程序从`index.html`中注册的一个点击事件开始，在文件的第50行，然后调用到`dgjs.js`中第18行的`setone()`方法，最后调用同一文件第4行的`setall()`方法后被中断到当前断点。在调用栈上点击，可以定位到源代码中相应的代码行。

![](https://developers.google.cn/web/tools/chrome-devtools/javascript/imgs/image_15.png)

#### 开启异步调用栈信息

开启异步调用栈信息，能够将异步调用函数，异步状态以前的调用栈信息也显示出来。

1. 打开开发者工具，切换到**Sources**面板
2. 勾选异步，如下图
 
 ![](http://p1.bpimg.com/582863/0faff68cc1db7586.png)

如下图所示，用动画演示了异步调用栈的用法。我们用jQuery库为左边的button添加点击事件，在点击事件处理函数中设置一个定时器，定时器过0.5s后执行函数f。在函数f內，使用debugger关键字进行中断。然后我们点击button，很明显，首先点击处理函数被调用，然后设置一个定时器，0.5s后，f函数被调用。但第一次，我们没有勾选异步调用栈，可以看到调用栈中只有一条调用信息，是由浏览器触发的定时器调用，因为定时器是异步执行的。然后我们勾选异步调用栈，再次点击button，当中断下来后，我们查看调用栈信息，会惊奇的发现有四条调用栈信息，其中还包括第三方库以及定时器之前的调用信息。

![](http://p1.bpimg.com/582863/0d23ea1ab31b95ec.gif)

#### 具名函数提高调用栈可读性

如下两图所示，第一个和第二个在逻辑上没有区别，第一个使用具有名称的函数，第二个使用匿名函数。查看两种情况下的调用栈，很明显，第一个调用栈显示(anonymous function)，当很多时，不利于阅读调用栈的信息。

![](https://developers.google.cn/web/tools/chrome-devtools/javascript/imgs/anon.png)

![](https://developers.google.cn/web/tools/chrome-devtools/javascript/imgs/named.png)